/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Copyright 2019 Joyent, Inc.
 *
 *
 * Summary:
 *
 *   This program is intended to be run on mako/storage zones in Manta and takes an instructions file
 *   (in the format generated by manta-garbage collector) and a storageId as arguments and then
 *   processes the instructions file, deleting files from /manta where possible.
 *
 *   It will write diagnostic information to stderr while it is operating and when it is complete it
 *   will write 6 integers to stdout separated by spaces. These values are:
 *
 *    1. The number of instructions (lines) processed
 *    2. The number of instructions that were invalid (did not have 4 fields)
 *    3. The number of instructions that did not match the storageId
 *    4. The number of objects where delete was attempted but the object was not found
 *    5. The total number of logical bytes in all files that were deleted
 *    6. The total number of physical bytes in all files that were deleted
 *
 *   The exit codes returned are:
 *
 *     0   Execution successful
 *     1   The instructions file contained 1 or more invalid instructions
 *     2   Usage error (usage message will also be printed to stderr)
 *
 *   In the case of exit code 2, no statistics will be printed to stdout.
 *
 */

use std::env;
use std::fs;
use std::io::prelude::*;
use std::io::{self, BufReader};
use std::os::unix::fs::MetadataExt;
use std::path::Path;
use std::process;

fn print_results(
    instruction_count: u64,
    invalid_instructions: u64,
    misdirected_instructions: u64,
    missing_objects: u64,
    logical_bytes_deleted: u64,
    physical_bytes_deleted: u64,
) {
    println!(
        "{} {} {} {} {} {}",
        instruction_count,
        invalid_instructions,
        misdirected_instructions,
        missing_objects,
        logical_bytes_deleted,
        physical_bytes_deleted
    );
}

fn main() -> io::Result<()> {
    let args: Vec<String> = env::args().collect();

    if args.len() != 3 {
        eprintln!("Usage: gc <instructions file> <storageId>");
        process::exit(2);
    }

    let mut instruction_count = 0;
    let mut invalid_instructions = 0;
    let mut logical_bytes_deleted = 0;
    let mut missing_objects = 0;
    let mut misdirected_instructions = 0;
    let mut physical_bytes_deleted = 0;

    let instruction_file_path = &args[1];
    let storage_id = &args[2].clone();

    /*
     * It is likely that we will encounter a path to an instructions file that does not exist. In
     * these cases we need to bail out of the program and let the wrapping shell script delete the
     * file.
     */
    if !Path::new(&instruction_file_path).exists() {
        eprintln!(
            "WARN: Instruction file '{}' did not exist",
            instruction_file_path
        );
        print_results(0, 0, 0, 0, 0, 0);
        process::exit(0);
    }

    let instructions_file = fs::File::open(instruction_file_path)?;
    let instructions = BufReader::new(instructions_file);

    for line in instructions.lines() {
        let instruction = line.unwrap();
        eprintln!("INFO: Processing instruction '{}'", instruction);

        instruction_count += 1;

        let instruction_fields: Vec<&str> = instruction.split_whitespace().collect();

        /*
         * Due to a bug in manta-garbage-collector it is possible that we will encounter invalid
         * instructions. If we do encounter an invalid instruction it is important that we preserve
         * the original instruction file for postmortem analysis. Here we check that the line has the
         * correct number of values and if not we log the invalid line, set invalid_instruction_seen
         * to true and skip to the next instruction.
         */
        if instruction_fields.len() < 4 {
            eprintln!("WARN: Invalid instruction '{}'", instruction);
            invalid_instructions += 1;
            continue;
        }

        if instruction_fields[1] != storage_id {
            misdirected_instructions += 1;
            continue;
        }

        /*
         * Sometimes we will encounter a situation where the object to be deleted has already been deleted.
         * In these cases we want to output that this happened and move forward without doing anything more
         * since this is an expected case.
         */
        let object = format!("/manta/{}/{}", instruction_fields[2], instruction_fields[3]);
        if !Path::new(&object).exists() {
            eprintln!("WARN: Object '{}' did not exist", object);
            missing_objects += 1;
            continue;
        }

        if let Ok(md) = fs::metadata(&object) {
            logical_bytes_deleted += md.len();
            physical_bytes_deleted += md.blocks() * 512;
        }

        fs::remove_file(object)?;
    }

    print_results(
        instruction_count,
        invalid_instructions,
        misdirected_instructions,
        missing_objects,
        logical_bytes_deleted,
        physical_bytes_deleted,
    );

    /*
     * If we encounter an invalid instruction, exit with code 1 which signals to the caller the current
     * instruction file should be preserved for later analysis.
     */
    if invalid_instructions > 0 {
        process::exit(1);
    }

    Ok(())
}
